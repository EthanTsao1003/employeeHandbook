interface 茶水:可以被加温的,有茶味道的  //茶水
{

}
interface 可以装茶水的  //茶杯
{
    茶水 get茶水();
    void set茶水(茶水 cs);
}

interface 可以产生茶水的  //茶壶
{
    茶水 产生茶水(可以被加温的 水,有茶味道的 茶叶);
}
interface 可以被加温的  //水
{
    void set温度();
}
interface 有茶味道的  //茶叶
{
    String get茶味道();
}
interface 可以加温的  //火
{
    void 加热(可以被加温的 水);
}

class _茶壶:可以产生茶水的
{
    protected  可以加温的 _火;
    protected  可以装茶水的 _茶杯;
    public _茶壶(可以加温的 火,可以装茶水的 茶杯)
    {
        _火 = 火;
        _茶杯 = 茶杯;
    }
    茶水 产生茶水(可以被加温的 水,有茶味道的 茶叶)
    {
        _火.加热(水);
        茶水 cs;
        茶杯.set茶水(cs);
        return cs;
        //return 水+茶叶; 这个代表可意会不可言传
    };
}
//更好的，符合O的
class _茶壶:可以产生茶水的,可以加温的,可以装茶水的
{
    protected  可以加温的 _火;
    protected  可以装茶水的 _茶杯;
    public _茶壶(可以加温的 火,可以装茶水的 茶杯)
    {
        _火 = 火;
        _茶杯 = 茶杯;
    }
    void 加热(可以被加温的 水){
        _火.加热(水);
    }
    茶水 get茶水()
    {
        return _茶杯.get茶水();
    }
    void set茶水(茶水 cs)
    {
        _茶杯.set茶水(cs);
    }
    茶水 产生茶水(可以被加温的 水,有茶味道的 茶叶)
    {
        加热(水);
        茶水 cs;
        set茶水(cs);
        return get茶水();
    };
}
//为什么更好？
class _茶壶:可以产生茶水的,可以加温的,可以装茶水的 //这样写不算滥用继承
//1.接口被我们改名了，火不是火，火是可以加温的，茶杯不是茶杯，茶杯是可以装茶水的，这样更符合I,不然茶壶继承火跟茶杯就显得很古怪
//2.在接口层面并没有混淆,茶壶的接口并没有继承其他多余的东西,而接口才是重要的
//3.继承的也不是实际的类而是接口，实际的类是被注入进来的
//4.这样写反而可以利用编译器自动填代码的功能帮我们生产更O的代码
{
    protected  可以加温的 _火;
    protected  可以装茶水的 _茶杯;
    public _茶壶(可以加温的 火,可以装茶水的 茶杯)
    {
        _火 = 火;
        _茶杯 = 茶杯;
    }
    void 加热(可以被加温的 水){
        //这个判断不能写到_火.加热()里面,因为火不应该有限制
        //无论是从代码的角度还是从自然规律的角度来考虑
        //但是为了茶壶的安全考虑我们还是要做一下判断
        //如果我们直接使用火的加热，每次调用我们就要取判断一下
        //这样写的话更符合O
        //并且利用编译器的特性，编译器自动填代码
        if(温度<=100)
        {
            _火.加热(水);
        }
        else
        {
            throw new Exception();
        }
            
    }
    茶水 get茶水()
    {
        return _茶杯.get茶水();
    }
    void set茶水(茶水 cs)
    {
        _茶杯.set茶水(cs);
    }
    茶水 产生茶水(可以被加温的 水,有茶味道的 茶叶)
    {
        加热(水);
        茶水 cs;
        set茶水(cs);
        return get茶水();
    };
}
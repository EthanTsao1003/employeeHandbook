using System;
using System.Collections.Generic;
using System.Text;


namespace 代码
{
    class 写东西:有署名的,锋利的//这里继承锋利的不算违反S，因为在接口层面我们把I做得很好
    {
        protected 铅笔 _铅笔;
        protected 锋利的 _削笔刀;
        public 写东西(铅笔 铅笔, 锋利的 削笔刀)//我们假设这是不耐久的铅笔，每写一段落都得提前削一遍，但是写一两个字不用削
        {
            _铅笔 = 铅笔;
            _削笔刀 = 削笔刀;
        }


        protected virtual void 写(String 填充文字)
        {
            
            Console.WriteLine(填充文字);
            //Console.WriteLine(""); 可以O，如果我想要用这种更宽的格式来写文档，写一行空一行、或者用其他的颜色来写、或者用其他的字体来写、或者我本身什么都不改变，
            //但是给子类留出修改的余地,子类可以通过重写这个方法随意的修改格式
            //但是如果我不这么做，直接在上面写console.writeLine(....),我的子类怎么去console.writeLine(....),
            //我要去改个颜色改个空行都要每一个console.writeLine(....)做修改，不O
            //这就是为什么一行的重复也算重复，也要抽离出去，目的就是为了O
        }
        public void 署名()  //这个文件夹的名字叫做在不相干的类中重复，但是为什么署名的重复我们没有新建一个不相干的类来解决，但是削铅笔的重复却要新建一个不相干的类来解决
        {
            写("名字");
            写("盖章");
            写("日期");
        }

        //我们通过编译器自动生成了这个方法，之后我们直接调用这个削()而不是削笔刀.削()。
        //一方面是省了几个文字
        //另一方面如果是要专门做修改的话，只需要在这里改，而不是跑去写短文那里改一次，跑去写文章那里又改两次
        //跟写字相关的削放在这里
        public void 削()
        {
            //假如你有一个画画的削，画画的削要求的角度或者粗细有另外的要求，你直接修改_削笔刀.削();会影响到画画的削，违反了O原则的闭
            //但是你用一个写字的削包装起来，就不会影响到画画的削
            //如果你要画画，那就用一个画画的削重新包装一下调用_削笔刀.削();
            //这样我对写字相关的削是开放的，不会影响到其他不相关的削(关闭的)
            //不要背口诀的时候看到O就只记得open,要记得还有一个close,open和close同等重要
            _削笔刀.削();
        }
    }
}

######第0、1条、公司的使命（让天下没有难做的数学）、公司的运营方向定位（通信）要达到凌晨4点要求，假如凌晨四点老板把你摇起来，你要能马上背诵。
0. 
    1. 可以重复的不能修改。
        1. String 、int 、class 等编程语言自带关键字
        2. 变量名、类名、方法名等使用的名称
        3. ………
    2. 可以修改的不能重复（出现一次不叫重复，出现两次及两次以上才叫重复）
        1. 实现逻辑
        2. 类的内部结构（方法、属性、变量） 父类子类可以避免类的内部结构重复这种情况
    3. 不修改不重复才是最好的
1. 遵守SOLID原则。
2. 代码不能出现重复（尽量什么都不要出现重复）,可以剪切粘贴不要复制粘贴
3. 每个类只能做一件事情，一个类只能有一个构造函数

4. 不要用静态（static,编程语言里面的静态，不是说不要有静态的思维、算法），静态的一切
	题：假如说：规定构造函数不可以重复使用(提示:跟静态有关)
    [资料](https://www.cnblogs.com/yts1dx/articles/3102500.html)
5. 不要用全局变量(静态变量也是全局变量)
6. 不要用单例模式(单例模式也是全局变量也是静态变量)
7. 命名要好好命名，读代码的时间会是写代码时间的十倍，即使是自己写的代码，所以不仅是在照顾别人，也是在照顾自己，如果在命名上出现了困难，大概率违反了S原则。
8. 也不要在命名里面放没有意义的词，如"学生对象"、"学生变量"、x、y、z，整个命名就没有意义了，也不要用学生1、学生2、学生3，用数组，“东西”最没有意义的词
9. 不要把所有变量都写到get(),set()，除非真的有必要。
10. 所有变量都不能public，但是在严格服从接口分离的情况下，是不是public，已经不重要了，所以可以放宽这一条要求
11. 不要重复用构造函数（出现一次不叫重复，出现两次及两次以上才叫重复），原因见第4条的题
12. 所有以上以下的规范都要在开发环境下严格执行（测试环境和配置环境不属于开发环境），其他情况下可以酌情放宽，原则是越可能被修改越要严格执行
13. 避免if，switch结构，转而用多态去实现，千篇一律的if结构也是一种重复，比如千篇一律的空指针检查，又比如if（这个人是男人）{...... }else if(这个人是女人){{......}else if(这是人妖){{......}，符合某种经常会出现的，而且判别内容是一样的if else if也算是代码重复
14. switch就真的别用了（这不是告诉你if else if else if{...... 更好）
15. 扩展功能不应该改变现有功能或对现有功能产生负作用
16. 保证上一条最安全可靠的方法就是不要改任何旧的代码，通过新增函数、类去扩展
    1. 不要轻易写注释，不要期望有人会读你的注释，更不要期望有人会更新你的注释，尽量把你写注释的时间拿来好好想想怎么命名吧。
    2. 但是如果你写了注释（自己就是想写或者老板特殊要求）你就要负责更新你的注释和更新你的代码同步到底。
    3. 就算写注释也用//的注释，不要用/*的注释。
17. 别缩写到别人看不懂，如魔数师写成mss、GameObject写成go
18. 不要把注释代码当成删除代码来用，如果你觉得这个代码以后还可能用得到，不如做好版本控制，多commit几次。
19. 不要在代码里面出现数字，把你需要的数字注入进来（错误示范:圆的面积=3.14*r*r,正确示范:先注入pi，然后圆的面积=pi*r*r）
20. 写代码出现循环（尤其是多层循环）的时候，无论是显性的循环(多个for放在一起)还是隐形的循环(一个for里面调用了方法，该方法里面也有循环)，停下来多思考一下是不是必要的。
21. 先想接口，再想实现
22. 随机数生成器或许是唯一一个合理的静态变量(全局变量)，但是永远不要用不被控制的随机数生成器即一定要有种子的随机数生成器并控制好他的种子 
23. 不要用null
24. 不要用枚举(enum)
25. 不要在一个class的代码里面出现其他class的名字（接口不是class）
26. 不要滥用继承，"是"和"有"的区别。人有手和脚，但人不应该继承手和脚，相反，男人和女人可以继承人，通常继承不该超过一级（男人和女人继承人是一级，但是老婆婆、中年妇女、少女再去继承女人就是二级），但是如果真的很恰当的话，超过一级也可以。
27. **不要用String去影响代码逻辑，除非是在数据库业务密切相关的情况下或者是远程请求密切相关的情况下，即使是这两种情况，也应该做好封装与隔离，不求做到彻底不用String,但求做到不重复违反这条原则。
在报错说明的情况，或者是在print情况下，可以用String,因为不影响代码逻辑，如果你的代码逻辑依赖到String上，那么你的代码逻辑设计有问题**
一个简单的测试：如果我跑过来瞎改你string的值，会导致程序产生bug，那这个string就是非法使用的。
28. 不要把print当成debug的工具。
29. 需要什么就注入什么，不要自己去瞎猜，也不要自己去造轮子，自己轻松，别人也轻松。
比如:在处理某份数据的时候，先要把数据洗干净（预处理）然后再处理，不如直接注入干净的数据，把预处理和后处理甩给其他人，别人公司鼓励大家多承担责任，我们公司鼓励大家把与自己无关的责任甩给其他人。怎么判定是否与自己有关？老板说了有关就是有关，老板没说就是没关。比如：老板只吩咐你去处理数据，没有吩咐你去预处理数据，那你就设定注入进来的数据都是预处理好的，把预处理的责任甩给其他人，任务完成后老板一看你的数据处理得很好，发现其他同事都已经被委以重任了，预处理这个任务还没有人做，让你去做预处理的任务，这个时候预处理就跟你有关了
30. 世界上的码农数每五年就会翻一倍，所以世界上一半的码农出现在五年前，另一半的码农是五年内才入行的，所以当你随机遇到一个码农，有50%的概率他的经验还不足5年，有75%的概率他的经验还不足十年，所以即使你现在是0年经验或者1年经验，你随机遇到的其他码农（无论是现实中还是网上别人发布代码），有一半是不值得你去学习的，所以谁值得你学习呢？以我们公司的员工手册为准
31. 所有的pri变量都应该是pro变量。所有的普通函数都应该是虚函数。但是这样规定会无谓的增加代码工作量所以我们遵从现用现改原则
32. 与S准则无关却必要的东西不要自己去造，不要自己去猜，注入进来。注入你需要的东西，注入你仅需要的东西，注入你直接需要的东西(接口)，不要注入你不需要的东西，只是因为他跟你需要的东西绑在一起（这说明I准则没做好） [DEMETER准则](https://www.cnblogs.com/zh7791/p/7922960.html)
33. 
34. 不要重载,用多态
    例：
    ```
    void Eat(Apple apple);
    void Eat(Banana banana);
    ⇒
    void Eat(Food food); (edited) 
    ```

    为什么不要重载？因为重载的要求极其严格不是普通码农能轻易掌握的。
    看如下例子：
    ```
    实数 Add(实数 a, 实数 b);
    复数 Add(复数 a, 复数 b);   
    ```
    问题是3.14既可以多态成实数，也可以多态成复数(3.14+0i)
    那么Add(3.14,3.14)应该被解释为实数版的Add还是复数版的Add？
    通过基本数学常识我们知道：结果都一样 一致性。
    不提编译器本身语言的局限性，光是这种一致性就不是一般程序可以精确达到的。

35. 使用任何第三方工具的时候像27条一样做好封装隔离
36. 当几个程序的运行顺序很关键的时候用依赖注入去确保他们的顺序
37. 违反以上准则有不同程度的严重性：在哪违反、违反几次
    1. 框架>业务代码>工厂>测试>环境设置
    2. 系统化地违反一次：做好设计，有计划的违反一次，违反一次之后就不需要再违法了并且违反这一次有一定的必要性。
    3. 不违反≈系统化地违反一次>违反一次>违反多次
38. 如果你不想别人不按照你的意愿使用你的代码，别把该操作的接口直接或间接给他
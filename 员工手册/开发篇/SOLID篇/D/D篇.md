###<center>依赖倒置原则</center>
1. 解释:高层模块不应该依赖底层模块，两者都应该依赖其抽象
2. a的代码出现b，我们就说a依赖b
3. 现在有26个类(当成26个字母解释)，如a-->b，依赖为1,a-->b-->c, 依赖为2，a<-->b-->c,依赖为3，可以认为一个箭头就1个依赖，要把这26个类之间的依赖降到最低，但是不允许出现连接断裂
    1. 例1:钢琴和音符的依赖关系   (26个字母的其中一个方法)
    2. 例2:咖啡，有个智能咖啡机，有个人想喝咖啡了，他去智能咖啡机上点了一杯咖啡，咖啡机做咖啡，做好就自动送过去了
    3. 例3:咖啡，有个智能咖啡机，有个人想喝咖啡了，他去智能咖啡机上点了一杯咖啡，咖啡机做咖啡，做好了发出滴滴滴
    4. 例4:一个自动打棒球的机器，分成两个部分，打和接，球来了自动接，自动打
    5. 需要的类
        1. 例1的类:钢琴、音符
        2. 例2、3的类:咖啡机、人、咖啡
        3. 例4的类:打机器、球、接机器
    6. 之间的依赖关系
        1. 例1的类:钢琴依赖音符
        2. 例2、3的类:咖啡机依赖咖啡、人依赖咖啡机
            1.事件,咖啡好了,人要处理这个事件,无论是哪个版本，咖啡都要发出这个事件,人要处理这个事件，咖啡机要认识这个人
            2.例2,送的版本，人不需要认识咖啡机,坐在那里等就行了
            3.例3，人需要认识咖啡机，过去取（一般情况）
        3. 例4的类:接机器依赖球、打机器依赖球
    7. 改善:
        1. 例1:多出来个第三方，琴键，钢琴依赖琴键来弹出音符
        2. 例2、3:咖啡就负责发送一个事件，不管发送给谁，人就负责处理这个事件，就别管是谁发送的这个事件,唯一都需要知道的事情就是咖啡，我们可以有第三方来作为一个中转，咖啡做出来之后就扔出来，别管来取的人是谁，第三方保证会接住，第三方把咖啡扔回去给那个人,咖啡机瞎扔就行，不需要知道第三方的存在，第三方会保证把他接住，第三方会想办法接住，人也不需要知道第三方是谁，人只要坐在哪里等着，如果一次做多个咖啡，有精细化的要求，需要第三方判断,哪个咖啡是谁的
        3. 例4: 多出来个第三方自动调整角度，打机器只负责打，接机器只负责接，一次打多个球，没有精细化的要求，也可以使用丢给第三方就不管了
2. 图解:
![img](../img/d.jpg )
<center> Copyright © 2020 珠海数镜空时科技有限公司 All Rights Reserved</center>